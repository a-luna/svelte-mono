import { validateDecoderInput, validateEncoderInput } from '$lib/dataPrep';
import { describe, expect, test } from 'vitest';

describe('validateEncoderInputChunks', () => {
	test('can create a map (no whitespace, no pad characters) for a 3-byte chunk of an ASCII string', () => {
		expect(validateEncoderInput('dog', 'ascii', 'base64')).toEqual({
			inputText: 'dog',
			inputEncoding: 'ascii',
			outputEncoding: 'base64',
			validationResult: {
				success: true,
				value: 'dog',
			},
			bytes: [100, 111, 103],
			hexBytes: ['64', '6F', '67'],
			hex: '64 6F 67',
			ascii: 'dog',
			utf8: {
				utf8: 'dog',
				hasCharacterNames: false,
				hasCombinedChars: false,
				stringLength: 3,
				encoded: 'dog',
				totalBytes: 3,
				hexBytes: ['64', '6F', '67'],
				hexMap: [],
				bytes: [100, 111, 103],
				charMap: [
					{
						char: 'd',
						isCombined: false,
						isASCII: true,
						hexBytes: ['64'],
						bytes: [100],
						codepoints: ['U+0064'],
						totalBytes: 1,
						encoded: 'd',
					},
					{
						char: 'o',
						isCombined: false,
						isASCII: true,
						hexBytes: ['6F'],
						bytes: [111],
						codepoints: ['U+006F'],
						totalBytes: 1,
						encoded: 'o',
					},
					{
						char: 'g',
						isCombined: false,
						isASCII: true,
						hexBytes: ['67'],
						bytes: [103],
						codepoints: ['U+0067'],
						totalBytes: 1,
						encoded: 'g',
					},
				],
			},
			binary: '011001000110111101100111',
			totalChunks: 1,
			lastChunkPadded: false,
			padLength: 0,
			chunks: [
				{
					bytes: [100, 111, 103],
					encoding: 'ascii',
					hex: '64 6F 67',
					hexBytes: ['64', '6F', '67'],
					ascii: 'dog',
					binary: '011001000110111101100111',
					isPadded: false,
					padLength: 0,
					inputMap: [
						{
							byte: 100,
							bin_word1: '0110',
							bin_word2: '0100',
							hex_word1: '6',
							hex_word2: '4',
							ascii: 'd',
							char: 'd',
							isWhiteSpace: false,
							groupId: '',
							bitGroups: [],
							characterId: '',
						},
						{
							byte: 111,
							bin_word1: '0110',
							bin_word2: '1111',
							hex_word1: '6',
							hex_word2: 'F',
							ascii: 'o',
							char: 'o',
							isWhiteSpace: false,
							groupId: '',
							bitGroups: [],
							characterId: '',
						},
						{
							byte: 103,
							bin_word1: '0110',
							bin_word2: '0111',
							hex_word1: '6',
							hex_word2: '7',
							ascii: 'g',
							char: 'g',
							isWhiteSpace: false,
							groupId: '',
							bitGroups: [],
							characterId: '',
						},
					],
				},
			],
		});
	});

	test('can create a map (no whitespace, WITH pad characters) for a 3-byte chunk of an ASCII string', () => {
		expect(validateEncoderInput('do', 'ascii', 'base64')).toEqual({
			inputText: 'do',
			inputEncoding: 'ascii',
			outputEncoding: 'base64',
			validationResult: {
				success: true,
				value: 'do',
			},
			bytes: [100, 111],
			hexBytes: ['64', '6F'],
			hex: '64 6F',
			ascii: 'do',
			utf8: {
				utf8: 'do',
				hasCharacterNames: false,
				hasCombinedChars: false,
				stringLength: 2,
				encoded: 'do',
				totalBytes: 2,
				hexBytes: ['64', '6F'],
				hexMap: [],
				bytes: [100, 111],
				charMap: [
					{
						char: 'd',
						isCombined: false,
						isASCII: true,
						hexBytes: ['64'],
						bytes: [100],
						codepoints: ['U+0064'],
						totalBytes: 1,
						encoded: 'd',
					},
					{
						char: 'o',
						isCombined: false,
						isASCII: true,
						hexBytes: ['6F'],
						bytes: [111],
						codepoints: ['U+006F'],
						totalBytes: 1,
						encoded: 'o',
					},
				],
			},
			binary: '0110010001101111',
			totalChunks: 1,
			lastChunkPadded: true,
			padLength: 2,
			chunks: [
				{
					bytes: [100, 111],
					encoding: 'ascii',
					hex: '64 6F',
					hexBytes: ['64', '6F'],
					ascii: 'do',
					binary: '011001000110111100',
					isPadded: true,
					padLength: 2,
					inputMap: [
						{
							byte: 100,
							bin_word1: '0110',
							bin_word2: '0100',
							hex_word1: '6',
							hex_word2: '4',
							ascii: 'd',
							char: 'd',
							isWhiteSpace: false,
							groupId: '',
							bitGroups: [],
							characterId: '',
						},
						{
							byte: 111,
							bin_word1: '0110',
							bin_word2: '1111',
							hex_word1: '6',
							hex_word2: 'F',
							ascii: 'o',
							char: 'o',
							isWhiteSpace: false,
							groupId: '',
							bitGroups: [],
							characterId: '',
						},
					],
				},
			],
		});
	});

	test('can create a map (WITH whitespace, no pad characters) for a single chunk of an ASCII string', () => {
		expect(validateEncoderInput(' do', 'ascii', 'base64')).toEqual({
			inputText: ' do',
			inputEncoding: 'ascii',
			outputEncoding: 'base64',
			validationResult: {
				success: true,
				value: ' do',
			},
			bytes: [32, 100, 111],
			hexBytes: ['20', '64', '6F'],
			hex: '20 64 6F',
			ascii: ' do',
			utf8: {
				utf8: ' do',
				hasCharacterNames: false,
				hasCombinedChars: false,
				stringLength: 3,
				encoded: '%20do',
				totalBytes: 3,
				hexBytes: ['20', '64', '6F'],
				hexMap: [],
				bytes: [32, 100, 111],
				charMap: [
					{
						char: ' ',
						isCombined: false,
						isASCII: true,
						hexBytes: ['20'],
						bytes: [32],
						codepoints: ['U+0020'],
						totalBytes: 1,
						encoded: '%20',
					},
					{
						char: 'd',
						isCombined: false,
						isASCII: true,
						hexBytes: ['64'],
						bytes: [100],
						codepoints: ['U+0064'],
						totalBytes: 1,
						encoded: 'd',
					},
					{
						char: 'o',
						isCombined: false,
						isASCII: true,
						hexBytes: ['6F'],
						bytes: [111],
						codepoints: ['U+006F'],
						totalBytes: 1,
						encoded: 'o',
					},
				],
			},
			binary: '001000000110010001101111',
			totalChunks: 1,
			lastChunkPadded: false,
			padLength: 0,
			chunks: [
				{
					bytes: [32, 100, 111],
					encoding: 'ascii',
					hex: '20 64 6F',
					hexBytes: ['20', '64', '6F'],
					ascii: ' do',
					binary: '001000000110010001101111',
					isPadded: false,
					padLength: 0,
					inputMap: [
						{
							byte: 32,
							bin_word1: '0010',
							bin_word2: '0000',
							hex_word1: '2',
							hex_word2: '0',
							ascii: 'ws',
							char: ' ',
							isWhiteSpace: true,
							groupId: '',
							bitGroups: [],
							characterId: '',
						},
						{
							byte: 100,
							bin_word1: '0110',
							bin_word2: '0100',
							hex_word1: '6',
							hex_word2: '4',
							ascii: 'd',
							char: 'd',
							isWhiteSpace: false,
							groupId: '',
							bitGroups: [],
							characterId: '',
						},
						{
							byte: 111,
							bin_word1: '0110',
							bin_word2: '1111',
							hex_word1: '6',
							hex_word2: 'F',
							ascii: 'o',
							char: 'o',
							isWhiteSpace: false,
							groupId: '',
							bitGroups: [],
							characterId: '',
						},
					],
				},
			],
		});
	});

	test('can create a map (WITH whitespace, WITH pad characters) for a 3-byte chunk of an ASCII string', () => {
		expect(validateEncoderInput(' d', 'ascii', 'base64')).toEqual({
			inputText: ' d',
			inputEncoding: 'ascii',
			outputEncoding: 'base64',
			validationResult: {
				success: true,
				value: ' d',
			},
			bytes: [32, 100],
			hexBytes: ['20', '64'],
			hex: '20 64',
			ascii: ' d',
			utf8: {
				utf8: ' d',
				hasCharacterNames: false,
				hasCombinedChars: false,
				stringLength: 2,
				encoded: '%20d',
				totalBytes: 2,
				hexBytes: ['20', '64'],
				hexMap: [],
				bytes: [32, 100],
				charMap: [
					{
						char: ' ',
						isCombined: false,
						isASCII: true,
						hexBytes: ['20'],
						bytes: [32],
						codepoints: ['U+0020'],
						totalBytes: 1,
						encoded: '%20',
					},
					{
						char: 'd',
						isCombined: false,
						isASCII: true,
						hexBytes: ['64'],
						bytes: [100],
						codepoints: ['U+0064'],
						totalBytes: 1,
						encoded: 'd',
					},
				],
			},
			binary: '0010000001100100',
			totalChunks: 1,
			lastChunkPadded: true,
			padLength: 2,
			chunks: [
				{
					bytes: [32, 100],
					encoding: 'ascii',
					hex: '20 64',
					hexBytes: ['20', '64'],
					ascii: ' d',
					binary: '001000000110010000',
					isPadded: true,
					padLength: 2,
					inputMap: [
						{
							byte: 32,
							bin_word1: '0010',
							bin_word2: '0000',
							hex_word1: '2',
							hex_word2: '0',
							ascii: 'ws',
							char: ' ',
							isWhiteSpace: true,
							groupId: '',
							bitGroups: [],
							characterId: '',
						},
						{
							byte: 100,
							bin_word1: '0110',
							bin_word2: '0100',
							hex_word1: '6',
							hex_word2: '4',
							ascii: 'd',
							char: 'd',
							isWhiteSpace: false,
							groupId: '',
							bitGroups: [],
							characterId: '',
						},
					],
				},
			],
		});
	});

	test('can create a map (no whitespace, no pad characters) for a 3-byte chunk of a hex string', () => {
		expect(validateEncoderInput('5f3c0a', 'hex', 'base64')).toEqual({
			inputText: '5f3c0a',
			inputEncoding: 'hex',
			outputEncoding: 'base64',
			validationResult: {
				success: true,
				value: '5f3c0a',
			},
			bytes: [95, 60, 10],
			hexBytes: ['5F', '3C', '0A'],
			hex: '5F 3C 0A',
			ascii: '',
			utf8: {
				utf8: '',
				hasCharacterNames: false,
				hasCombinedChars: false,
				stringLength: 0,
				encoded: '',
				totalBytes: 0,
				hexBytes: [],
				hexMap: [
					{
						byte: 0,
						bin_word1: '',
						bin_word2: '',
						hex_word1: '',
						hex_word2: '',
						ascii: '',
						char: '',
						isWhiteSpace: false,
						groupId: '',
						bitGroups: [
							{
								groupId: '',
								bits: '',
							},
						],
						characterId: '',
					},
				],
				bytes: [],
				charMap: [
					{
						char: '',
						isCombined: false,
						isASCII: false,
						hexBytes: [],
						bytes: [],
						codepoints: [],
						unicodeNames: [],
						unicodeBlocks: [],
						totalBytes: 0,
						encoded: '',
						charMap: [
							{
								char: '',
								isCombined: false,
								isASCII: false,
								hexBytes: [],
								bytes: [],
								codepoint: '',
								unicodeName: '',
								unicodeBlock: '',
								totalBytes: 0,
								encoded: '',
								hexMap: [
									{
										byte: 0,
										bin_word1: '',
										bin_word2: '',
										hex_word1: '',
										hex_word2: '',
										ascii: '',
										char: '',
										isWhiteSpace: false,
										groupId: '',
										bitGroups: [
											{
												groupId: '',
												bits: '',
											},
										],
										characterId: '',
									},
								],
							},
						],
						hexMap: [
							{
								byte: 0,
								bin_word1: '',
								bin_word2: '',
								hex_word1: '',
								hex_word2: '',
								ascii: '',
								char: '',
								isWhiteSpace: false,
								groupId: '',
								bitGroups: [
									{
										groupId: '',
										bits: '',
									},
								],
								characterId: '',
							},
						],
					},
				],
			},
			binary: '010111110011110000001010',
			totalChunks: 1,
			lastChunkPadded: false,
			padLength: 0,
			chunks: [
				{
					bytes: [95, 60, 10],
					encoding: 'hex',
					hex: '5F 3C 0A',
					hexBytes: ['5F', '3C', '0A'],
					ascii: '',
					binary: '010111110011110000001010',
					isPadded: false,
					padLength: 0,
					inputMap: [
						{
							byte: 95,
							bin_word1: '0101',
							bin_word2: '1111',
							hex_word1: '5',
							hex_word2: 'F',
							ascii: '',
							char: '_',
							isWhiteSpace: false,
							groupId: '',
							bitGroups: [],
							characterId: '',
						},
						{
							byte: 60,
							bin_word1: '0011',
							bin_word2: '1100',
							hex_word1: '3',
							hex_word2: 'C',
							ascii: '',
							char: '<',
							isWhiteSpace: false,
							groupId: '',
							bitGroups: [],
							characterId: '',
						},
						{
							byte: 10,
							bin_word1: '0000',
							bin_word2: '1010',
							hex_word1: '0',
							hex_word2: 'A',
							ascii: '',
							char: '\n',
							isWhiteSpace: true,
							groupId: '',
							bitGroups: [],
							characterId: '',
						},
					],
				},
			],
		});
	});
});

describe('validateDecoderInputChunks', () => {
	test('can create a map for a base64 string (encoding: base64, length: 4, padding: None)', () => {
		expect(validateDecoderInput('ZG9n', 'base64')).toEqual({
			inputText: 'ZG9n',
			inputEncoding: 'base64',
			validationResult: {
				success: true,
			},
			base64: 'ZG9n',
			binary: '011001000110111101100111',
			totalChunks: 1,
			lastChunkPadded: false,
			padLength: 0,
			chunks: [
				{
					base64: 'ZG9n',
					binary: '011001000110111101100111',
					encoding: 'base64',
					isPadded: false,
					padLength: 0,
					inputMap: [
						{
							bin: '011001',
							dec: 25,
							b64: 'Z',
							isPad: false,
							groupId: '',
							bitGroups: [],
						},
						{
							bin: '000110',
							dec: 6,
							b64: 'G',
							isPad: false,
							groupId: '',
							bitGroups: [],
						},
						{
							bin: '111101',
							dec: 61,
							b64: '9',
							isPad: false,
							groupId: '',
							bitGroups: [],
						},
						{
							bin: '100111',
							dec: 39,
							b64: 'n',
							isPad: false,
							groupId: '',
							bitGroups: [],
						},
					],
				},
			],
		});
	});

	test('can create a map for a base64 string (encoding: base64, length: 3, padding: 1)', () => {
		expect(validateDecoderInput('ZG8=', 'base64')).toEqual({
			inputText: 'ZG8=',
			inputEncoding: 'base64',
			validationResult: {
				success: true,
			},
			base64: 'ZG8',
			binary: '011001000110111100',
			totalChunks: 1,
			lastChunkPadded: true,
			padLength: 1,
			chunks: [
				{
					base64: 'ZG8',
					binary: '011001000110111100',
					encoding: 'base64',
					isPadded: true,
					padLength: 1,
					inputMap: [
						{
							bin: '011001',
							dec: 25,
							b64: 'Z',
							isPad: false,
							groupId: '',
							bitGroups: [],
						},
						{
							bin: '000110',
							dec: 6,
							b64: 'G',
							isPad: false,
							groupId: '',
							bitGroups: [],
						},
						{
							bin: '111100',
							dec: 60,
							b64: '8',
							isPad: false,
							groupId: '',
							bitGroups: [],
						},
						{
							bin: '',
							dec: 0,
							b64: '=',
							isPad: true,
							groupId: '',
							bitGroups: [],
						},
					],
				},
			],
		});
	});
});
